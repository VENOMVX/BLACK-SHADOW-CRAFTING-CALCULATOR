<!DOCTYPE html>
<html>
<head>
  <title>Black Shadow's Crafting Calculator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #121212;
      color: #eee;
      padding: 20px;
    }
    h1 {
      color: #00ffcc;
    }
    select, input, button {
      padding: 8px;
      margin: 10px 0;
      font-size: 16px;
    }
    .output {
      margin-top: 20px;
      background-color: #1e1e1e;
      padding: 15px;
      border-radius: 8px;
      white-space: pre-wrap;
    }
    #recipeContainer h3 {
      margin-top: 1em;
      color: #2a9d8f;
      font-size: 1.2em;
    }
    .recipe {
      padding-left: 1em;
    }
  </style>
</head>
<body>
  <h1>ðŸ”§ Black Shadow's Crafting Calculator</h1>

  <label for="item">Choose item:</label><br>
  <select id="item">
    <option value="">-- Select an item --</option>
    <!-- All item options go here -->
  </select><br>

  <label for="qty">Quantity:</label><br>
  <input type="number" id="qty" value="1" min="1"><br>

  <label for="sortType">Sort Recipes:</label><br>
  <select id="sortType" onchange="handleSortChange()">
    <option value="none">-- No Sorting --</option>
    <option value="alphabetical">Sort by Type (Aâ€“Z)</option>
    <option value="grouped">Group by Type</option>
  </select><br>

  <button onclick="calculate()">Calculate</button>
  <div class="output" id="output"></div>

  <script>
    // Paste your full baseMaterials and recipes objects here (already formatted)
    // Then add the following functions:

    function sortRecipesByType(recipesObj) {
      return Object.entries(recipesObj)
        .map(([name, data]) => ({ name, ...data }))
        .sort((a, b) => (a.type || "").localeCompare(b.type || ""));
    }

    function groupRecipesByType(recipesObj) {
      const grouped = {};
      for (const [name, data] of Object.entries(recipesObj)) {
        const type = data.type || "Unknown";
        if (!grouped[type]) grouped[type] = [];
        grouped[type].push({ name, ...data });
      }
      return grouped;
    }

    function renderGroupedRecipes(grouped) {
      const container = document.getElementById("output");
      container.innerHTML = "";
      for (const type in grouped) {
        const header = document.createElement("h3");
        header.textContent = type;
        container.appendChild(header);
        grouped[type].forEach(recipe => {
          const div = document.createElement("div");
          div.className = "recipe";
          div.textContent = recipe.name;
          container.appendChild(div);
        });
      }
    }

    function renderRecipes(recipeList) {
      const container = document.getElementById("output");
      container.innerText = "ðŸ§¾ Available Recipes:\n" + recipeList.map(r => r.name).join("\n");
    }

    function handleSortChange() {
      const value = document.getElementById("sortType").value;
      if (value === "alphabetical") {
        const sorted = sortRecipesByType(recipes);
        renderRecipes(sorted);
      } else if (value === "grouped") {
        const grouped = groupRecipesByType(recipes);
        renderGroupedRecipes(grouped);
      } else {
        renderRecipes(Object.entries(recipes).map(([name, data]) => ({ name, ...data })));
      }
    }

    function calculate() {
      const item = document.getElementById("item").value;
      const qty = parseInt(document.getElementById("qty").value);
      const recipe = recipes[item];
      const output = [];
      const rawTotals = {};

      if (!recipe) {
        document.getElementById("output").innerText = "âŒ Item not found or not selected.";
        return;
      }

      output.push(`ðŸ”© Materials for ${qty} Ã— ${item}:\n`);

      for (const [part, count] of Object.entries(recipe)) {
        if (part !== "multiplier" && part !== "type") {
          const total = count * qty * recipe.multiplier;
          output.push(`${part}: ${total}`);
          if (baseMaterials[part]) {
            for (const [raw, rawCount] of Object.entries(baseMaterials[part])) {
              rawTotals[raw] = (rawTotals[raw] || 0) + rawCount * total;
            }
          }
        }
      }

      output.push(`\nðŸ§± Raw Materials Needed:\n`);
      for (const [raw, total] of Object.entries(rawTotals)) {
        output.push(`${raw}: ${total}`);
      }

      document.getElementById("output").innerText = output.join("\n");
    }

    window.onload = () => {
      renderRecipes(Object.entries(recipes).map(([name, data]) => ({ name, ...data })));
    };
  </script>
</body>
</html>
  
